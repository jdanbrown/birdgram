import { EventEmitter } from 'fbemitter';
import _ from 'lodash';
import { AsyncStorage } from 'react-native';
import RNFB from 'rn-fetch-blob';
const {fs} = RNFB;

import { GeoCoords } from 'app/components/Geo';
import { DraftEdit, Edit, EditSource, matchSourceId, SearchRecs, Source, SourceId, UserSource, XCSource } from 'app/datatypes';
import { debug_print, log, Log, rich } from 'app/log';
import { NativeSpectro } from 'app/native/Spectro';
import { Places } from 'app/places';
import {
  assert, basename, chance, ensureDir, ensureParentDir, extname, ifEmpty, ifNil, ifNull, ifUndefined, json,
  JsonSafeNumber, Interval, local, mapEmpty, mapNil, mapNull, mapUndefined, match, matchNull, matchUndefined, NoKind,
  Omit, parseUrl, parseUrlNoQuery, parseUrlWithQuery, pretty, qsSane, requireSafePath, safeParseInt, safeParseIntOrNull,
  safePath, showDate, showSuffix, splitFirst, stripExt, throw_, tryElse, typed, unjson,
} from 'app/utils';

// TODO How to prevent callers from constructing a Rec i/o one of the subtypes? [Maybe classes with constructors?]
export type Rec = XCRec | UserRec | EditRec;

export interface XCRec extends _RecImpl {
  kind:  'xc';
  xc_id: number;
}

export interface UserRec extends _RecImpl {
  kind:    'user';
  f_preds: Array<number>;
}

export interface EditRec extends _RecImpl {
  kind:      'edit';
  edit:      Edit;
  // parent: Rec;  // Require consumers to load the parent Rec, else we risk O(parents) work to load an edit rec
  f_preds:   Array<number>;
}

export interface _RecImpl {

  // bubo
  source_id: SourceId; // More appropriate than id for mobile (see python util.rec_to_source_id for details)
  // id: string;       // Hide so that we don't accidentally use it (so that we'll get type errors if we try)
  duration_s: number;

  // xc
  species:               string; // (From ebird)
  species_taxon_order:   string; // (From ebird)
  species_species_group: string; // (From ebird)
  species_family:        string; // (From ebird)
  species_order:         string; // (From ebird)
  species_com_name:      string; // (From xc)
  species_sci_name:      string; // (From xc)
  recs_for_sp:           number;
  quality:               Quality;
  lat?:                  number;
  lng?:                  number;
  date:                  string; // sqlite datetime
  month_day:             string; // sqlite string
  year:                  number; // sqlite bigint
  place:                 string;
  place_only:            string;
  state:                 string;
  state_only:            string;
  recordist:             string;
  license_type:          string;
  remarks:               string;

  // HACK Provided only from SearchScreen.loadRecsFromQuery -> rec case
  //  - TODO Split out SearchRecResult for /rec, separate from both query_rec and search results for /species, /random, etc.
  slp?:  number;
  d_pc?: number;

}

export type Quality = 'A' | 'B' | 'C' | 'D' | 'E' | 'no score';
export type F_Preds = Array<number>;

export const Quality = {
  values: ['A', 'B', 'C', 'D', 'E', 'no score'] as Array<Quality>,
};

export function matchRec<X>(rec: Rec, cases: {
  xc:   (rec: XCRec,   source: XCSource)   => X,
  user: (rec: UserRec, source: UserSource) => X,
  edit: (rec: EditRec, source: EditSource) => X,
}): X {
  // HACK Switch on rec.source_id until we refactor all Rec constructors to include .kind
  return matchSourceId(rec.source_id, {
    null: sourceId => { throw `matchRec: No Rec should have an invalid sourceId: ${sourceId}`; },
    xc:   source   => cases.xc   (rec as XCRec,   source),
    user: source   => cases.user (rec as UserRec, source),
    edit: source   => cases.edit (rec as EditRec, source),
  });
}

export interface Rec_f_preds {
  [key: string]: number;
}

export interface SpectroPathOpts {
  f_bins:  number;
  denoise: boolean;
}

export const Rec = {

  // Primary storage (DocumentDir)
  userRecDir:      `${fs.dirs.DocumentDir}/user-recs-v0`,  // User recordings
  editDir:         `${fs.dirs.DocumentDir}/edits-v0`,      // User edits
  // Files that can be regenerated by need (CacheDir)
  spectroCacheDir: `${fs.dirs.CacheDir}/spectros-v0`, // Spectros will recreate if missing

  // Events
  emitter: new EventEmitter(),

  audioPath: (rec: Rec): string => matchRec(rec, {
    xc:   (rec, source) => XCRec.audioPath(rec),
    user: (rec, source) => UserRec.audioPath(source),
    edit: (rec, source) => EditRec.audioPath(source),
  }),

  spectroPath: (
    rec:  Rec,
    opts: SpectroPathOpts, // Ignored for xc rec [TODO Clean up]
  ): string => matchRec(rec, {
    xc:   (rec, source) => XCRec.spectroPath(rec),
    user: (rec, source) => UserRec.spectroPath(source, opts),
    edit: (rec, source) => EditRec.spectroPath(source, opts),
  }),

  // A writable spectroCachePath for nonstandard f_bins/denoise
  //  - HACK Shared across UserRec.spectroPath + RecordScreen:EditRecording
  //    - EditRecording can't use UserRec.spectroPath because it assumes a user sourceId
  //    - EditRecording can't use Rec.spectroPath because it maps xc sourceIds to their static asset spectroPath (40px)
  //    - TODO Add concept for "writable spectroPath for user/xc rec"
  spectroCachePath: (source: Source, opts: SpectroPathOpts): string => {
    return [
      `${Rec.spectroCacheDir}`,
      `${Source.pathBasename(source)}.spectros`,
      `f_bins=${opts.f_bins},denoise=${opts.denoise}.png`,
    ].join('/');
  },

  f_preds: (rec: Rec): Rec_f_preds => {
    return matchRec(rec, {
      xc:   rec => rec as unknown as Rec_f_preds,                               // Expose .f_preds_* from sqlite
      user: rec => _.fromPairs(rec.f_preds.map((p, i) => [`f_preds_${i}`, p])), // Materialize {f_preds_*:p} from .f_preds
      edit: rec => _.fromPairs(rec.f_preds.map((p, i) => [`f_preds_${i}`, p])), // Materialize {f_preds_*:p} from .f_preds
    });
  },

  hasCoords: (rec: Rec): boolean => {
    return !_.isNil(rec.lat) && !_.isNil(rec.lng);
  },

  placeNorm: (placeLike: string): string => {
    return placeLike.split(', ').reverse().map(x => Rec.placePartAbbrev(x)).join(', ');
  },
  placePartAbbrev: (part: string): string => {
    const ret = (
      Places.countryCodeFromName[part] ||
      Places.stateCodeFromName[part] ||
      part
    );
    return ret;
  },

  recUrl: (rec: Rec): string | null => {
    return matchRec(rec, {
      xc:   rec => XCRec.recUrl(rec),
      user: rec => null,
      edit: rec => null, // TODO(user_metadata): Requires reading .metadata.json (see DB.loadRec)
    });
  },

  speciesUrl: (rec: Rec): string => {
    return `https://www.allaboutbirds.org/guide/${rec.species_com_name.replace(/ /g, '_')}`;
  },

  // TODO Open in user's preferred map app i/o google maps
  //  - Docs for zoom levels: https://developers.google.com/maps/documentation/maps-static/dev-guide#Zoomlevels
  mapUrl: (rec: Rec, opts: {zoom: number}): string | null => {
    if (!Rec.hasCoords(rec)) {
      // TODO How to zoom when we don't know (lat,lng)?
      const {place} = rec;
      return `https://maps.google.com/maps?oi=map&q=${place}`;
    } else {
      // TODO How to show '$place' as label instead of '$lat,$lng'?
      const {lat, lng, place} = rec;
      const {zoom} = opts;
      return `https://www.google.com/maps/place/${lat},${lng}/@${lat},${lng},${zoom}z`;
    }
  },

  listAudioSources: async <FileSource>(FileRec: {
    audioDir:                string,
    sourceFromAudioFilename: (filename: string) => Promise<FileSource | null>,
  }): Promise<Array<FileSource>> => {
    return _.flatten(await Promise.all(
      (await Rec.listAudioFilenames(FileRec.audioDir)).map(async filename => {
        const source = await FileRec.sourceFromAudioFilename(filename);
        if (!source) {
          log.warn("listAudioSources: Dropping: Failed to parse sourceId", rich({
            audioDir: FileRec.audioDir,
            filename,
          }));
          return [];
        } else {
          return [source];
        }
      })
    ));
  },

  listAudioPaths: async (dir: string): Promise<Array<string>> => {
    return (await Rec.listAudioFilenames(dir)).map(x => `${dir}/${x}`);
  },

  listAudioFilenames: async (dir: string): Promise<Array<string>> => {
    const excludes = [/\.metadata\.json$/];
    return (
      (await fs.ls(await ensureDir(dir)))
      .filter(x => !_.some(excludes, exclude => exclude.test(x)))
      .sort()
    );
  },

};

export const XCRec = {

  pathBasename: (source: XCSource): string => {
    return safePath(Source.stringify(source)); // e.g. 'xc-1234'
  },

  audioPath: (rec: XCRec): string => {
    return SearchRecs.assetPath('audio', rec.species, rec.xc_id, 'mp4');
  },

  // TODO (When needed)
  // sourceFromAudioFilename: async (filename: string): Promise<XCSource | null> => {
  //   ...
  // },

  spectroPath: (rec: XCRec): string => {
    // From assets, not spectroCacheDir
    return SearchRecs.assetPath('spectro', rec.species, rec.xc_id, 'png');
  },

  recUrl: (rec: XCRec): string => {
    return `https://www.xeno-canto.org/${rec.xc_id}`;
  },

};

export const UserRec = {

  log: new Log('UserRec'),

  audioDir: Rec.userRecDir,

  pathBasename: (source: UserSource): string => {
    return stripExt(source.filename); // e.g. 'user-20190109205640977-336b2bb7'
  },

  audioPath: (source: UserSource): string => {
    // Use preserved filename so we can roundtrip outdated filename formats (e.g. saved user recs from old code versions)
    return `${UserRec.audioDir}/${source.filename}`;
  },

  sourceFromAudioFilename: async (filename: string): Promise<UserSource | null> => {
    return mapNull(Source.parse(`user:${filename}`), x => x as UserSource); // HACK Type
  },

  spectroPath: (source: UserSource, opts: SpectroPathOpts): string => {
    return Rec.spectroCachePath(source, opts);
  },

  new: async (audioPath: string): Promise<UserSource> => {

    // Make UserSource
    const userSource = await UserRec.sourceFromAudioFilename(basename(audioPath));
    if (!userSource) throw `stopRecording: audioPath from Nativespectro.stop() should parse to source: ${audioPath}`;

    // Notify listeners that a new UserRec was created (e.g. SavedScreen)
    Rec.emitter.emit('user', userSource);

    return userSource;
  },

  newAudioPath: async (ext: string, metadata: {
    coords: GeoCoords | null,
  }): Promise<string> => {

    // Create audioPath
    const source = UserSource.new({
      created: new Date(),
      uniq:    chance.hash({length: 8}), // Long enough to be unique across users
      ext,
    });
    const audioPath = UserRec.audioPath(source);

    // Ensure parent dir for caller
    //  - Also for us, to write the metadata file (next step)
    ensureParentDir(audioPath);

    // Save metadata
    const metadataPath = `${audioPath}.metadata.json`;
    const metadataData = pretty(metadata);
    await fs.createFile(metadataPath, metadataData, 'utf8');

    // Done
    UserRec.log.info('newAudioPath', rich({audioPath, metadataPath, metadata}));
    return audioPath;

  },

  // Wrap Rec.listAudio*
  listAudioSources:   async (): Promise<Array<UserSource>> => Rec.listAudioSources   (UserRec),
  listAudioPaths:     async (): Promise<Array<string>>     => Rec.listAudioPaths     (UserRec.audioDir),
  listAudioFilenames: async (): Promise<Array<string>>     => Rec.listAudioFilenames (UserRec.audioDir),

};

export const EditRec = {

  log: new Log('EditRec'),

  audioDir: Rec.editDir,

  // Give edit rec files a proper audio file ext, else e.g. ios AKAudioFile(forReading:) fails to infer the filetype
  //  - Use .wav to match kAudioFormatLinearPCM in NativeSpectro.editAudioPathToAudioPath
  audioExt: 'wav',

  // Problem: filename/path limits are very small, so we can't represent all Edit fields in an EditRec filename
  //  - Solution: omit .parent from filenames and store in AsyncStorage, keyed by Edit.uniq
  //  - e.g. ios: NAME_MAX=255 (max bytes in filename), PATH_MAX=1024 (max bytes in path)
  //    - https://github.com/theos/sdks/blob/2236ceb/iPhoneOS11.2.sdk/usr/include/sys/syslimits.h
  pathBasename: (source: EditSource): string => {
    const {edit} = source;
    return `edit-${Source.stringifyDate(edit.created)}-${edit.uniq}`; // e.g. 'edit-20190108011526401-d892e4be'
  },

  audioPath: (source: EditSource): string => {
    const pathBasename = Source.pathBasename(source);
    return `${EditRec.audioDir}/${pathBasename}.${EditRec.audioExt}`;
  },

  sourceFromAudioFilename: async (filename: string): Promise<EditSource | null> => {
    const ext = extname(filename).replace(/^\./, '');
    if (ext != EditRec.audioExt) throw `Expected ext[${EditRec.audioExt}], got ext[${ext}] in filename[${filename}]`;

    // Load Edit (AsyncStorage)
    //  - e.g. .parent can't safely store in the filename (too long)
    //  - TODO Perf: refactor callers so we can use AsyncStorage.multiGet
    const pathBasename = basename(filename, `.${ext}`);
    return mapNull(await Edit.load(pathBasename), edit => typed<EditSource>({
      kind: 'edit',
      edit,
    }));

  },

  spectroPath: (source: EditSource, opts: SpectroPathOpts): string => {
    return Rec.spectroCachePath(source, opts);
  },

  new: async (props: {parent: Rec, draftEdit: DraftEdit}): Promise<EditSource> => {
    const {parent, draftEdit} = props;

    // Make editSource <- edit <- (parent, draftEdit)
    const edit = {
      ...draftEdit,
      parent:  parent.source_id,
      created: new Date(),
      uniq:    chance.hash({length: 8}),
    };
    const editSource: EditSource = {
      kind: 'edit',
      edit,
    };

    // Store Edit (AsyncStorage)
    //  - e.g. .parent can't safely store in the filename (too long)
    await Edit.store(EditRec.pathBasename(editSource), edit);

    // Edit parent audio file -> edit audio file
    const parentAudioPath = Rec.audioPath(parent);
    const editAudioPath   = await EditRec.newAudioPath(edit, {parent});
    await NativeSpectro.editAudioPathToAudioPath({
      parentAudioPath,
      editAudioPath,
      draftEdit: typed<DraftEdit>(edit),
    });

    // Notify listeners that a new EditRec was created (e.g. SavedScreen)
    Rec.emitter.emit('edit', editSource);

    return editSource;
  },

  newAudioPath: async (edit: Edit, metadata: {
    // Include all parent rec fields in metadata
    //  - Includes all rec metadata (species), but no rec assets (audio, spectro)
    //  - [Unstable api] Also happens to include f_preds because we store them in the db i/o as an asset file
    //  - Namespace under .parent, so that non-inheritable stuff like species/quality/duration_s doesn't get confused
    parent: Rec,
  }): Promise<string> => {

    // Create audioPath
    const source: EditSource = {kind: 'edit', edit};
    const audioPath = EditRec.audioPath({kind: 'edit', edit});

    // Ensure parent dir for caller
    //  - Also for us, to write the metadata file (next step)
    await ensureParentDir(audioPath);

    // Save metadata
    const metadataPath = `${audioPath}.metadata.json`;
    const metadataData = pretty(metadata);
    await fs.createFile(metadataPath, metadataData, 'utf8');

    // Done
    EditRec.log.info('newAudioPath', rich({audioPath, metadataPath, edit, metadata}));
    return audioPath;

  },

  // Wrap Rec.listAudio*
  listAudioSources:   async (): Promise<Array<EditSource>> => Rec.listAudioSources   (EditRec),
  listAudioPaths:     async (): Promise<Array<string>>     => Rec.listAudioPaths     (EditRec.audioDir),
  listAudioFilenames: async (): Promise<Array<string>>     => Rec.listAudioFilenames (EditRec.audioDir),

};
