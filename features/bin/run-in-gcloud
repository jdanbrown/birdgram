#!/usr/bin/env python
#
# Example auth, e.g. for deploys:
#   GOOGLE_APPLICATION_CREDENTIALS=~/.gcloud/gcloud-service-account-bubo.json bin/run-in-gcloud ...

import atexit
from datetime import datetime, timedelta
import json
import os
import re
import shlex
import subprocess
import sys
import time

from attrdict import AttrDict
import click
import crayons
import dataclasses
from dataclasses import dataclass
from potoo.pretty import pp


# click: Default option(show_default=True)
_click_option = click.option
click.option = lambda *args, **kwargs: _click_option(*args, **{'show_default': True, **kwargs})


@click.command(context_settings=dict(
    help_option_names=['-h', '--help'],
    max_content_width=click.get_terminal_size()[0],
))
@click.option('--project', default='bubo-1')
@click.option('--zone', default='us-west1-b')
@click.option('--machine-type', default='n1-standard-4', help='https://cloud.google.com/compute/pricing')
@click.option('--instance-name', default=None, help='Defaults to: "<instance-name-prefix>-<timestamp>"')
@click.option('--instance-name-prefix', default='run-in-gcloud')
@click.option('--reuse', default=None)
@click.option('--create-instance/--no-create-instance', default=True)
@click.option('--delete-instance/--no-delete-instance', default=True)
@click.option('--image-project', default='cos-cloud')
@click.option('--image', default='cos-stable-67-10575-55-0')
@click.option('--boot-disk-size', default='200GB')
@click.option('--boot-disk-type', default='pd-standard')
@click.option('--preemptible/--no-preemptible', default=False)
@click.option('--await-ready/--no-await-ready', default=True)
@click.option('--username', default=None, help='Defaults to your os-login username')
@click.option('--container-image', default=None, help='Run command in container if given, else run in the instance')
@click.option('--container-name', default=None, help='Defaults to instance_name')
@click.option('--docker-pull', default='sudo docker pull')
@click.option('--docker-run', default='sudo docker run -it --privileged --restart=no --rm')
@click.argument('command', nargs=1, required=False)  # One cmd string, e.g. quoted by the user
def main(
    project,
    zone,
    machine_type,
    instance_name,
    instance_name_prefix,
    reuse,
    create_instance,
    delete_instance,
    image_project,
    image,
    boot_disk_size,
    boot_disk_type,
    preemptible,
    await_ready,
    username,
    container_image,
    container_name,
    docker_pull,
    docker_run,
    command,
):

    gcloud = GCloud(
        project=project,
    )

    # Args
    instance_name = instance_name or '%s-%s' % (
        instance_name_prefix,
        re.sub('[^0-9T]', '-', datetime.utcnow().isoformat()).lower(),
    )
    if reuse:
        create_instance = False
        delete_instance = False
        await_ready = False
        instance_name = reuse
    if command is None:
        command = 'bash'

    # Delete instance on exit
    #   - Use atexit so we can exec
    if delete_instance:
        def _atexit():
            gcloud('compute', 'instances', 'delete', instance_name,
                zone=zone,
                _mode='async',
            )
        atexit.register(_atexit)

    # Create instance
    if create_instance:
        print(color('blue', 'Creating instance...'))
        [res] = gcloud('beta', 'compute', 'instances', 'create', instance_name,
            zone=zone,
            image_project=image_project,
            image=image,
            boot_disk_type=boot_disk_type,
            # tags='http-server,https-server',  # For ports 80/443
            boot_disk_size=boot_disk_size,
            machine_type=machine_type,
            preemptible=preemptible,
        )
        assert res['name'] == instance_name
        external_ip = res['networkInterfaces'][0]['accessConfigs'][0]['natIP']
        print(color('blue', 'Created instance:'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        print(color('blue', '  external_ip: %s' % external_ip))

    if await_ready or command:
        username = username or (
            gcloud('compute', 'os-login', 'describe-profile')['posixAccounts'][0]['username']
        )

    # Wait until ssh'ing into the instance succeeds
    if await_ready:
        print(color('blue', 'Awaiting instance ready...'))
        retry(times=60, delay_s=1, f=lambda: (
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _end_args=['--', 'true'],
            )
        ))
        print(color('blue', 'Instance ready'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        if create_instance:
            print(color('blue', '  external_ip: %s' % external_ip))

    # Run command via ssh
    #   - WARNING Careful with retry here: need to distinguish transient (network) vs. non-transient (command) errors
    if command:
        command = 'bash -c %s' % shlex.quote(command)
        if not container_image:
            print(color('blue', f'Running command on instance[{instance_name}]...'))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-t', command],
            )
        else:
            container_name = container_name or instance_name
            print(color('blue', 'Running command on %s...' % ' / '.join([
                f'instance[{instance_name}]',
                f'image[{container_image}]',
                f'container[{container_name}]',
            ])))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-t', ' '.join([
                    'set -x &&',
                    docker_pull,
                    shlex.quote(container_image),
                    '&&',
                    docker_run,
                    '--name=%s' % shlex.quote(container_name),
                    shlex.quote(container_image),
                    command,
                ])],
            )


@dataclass
class GCloud:
    """
    A thin wrapper around the gcloud cli, because it's better documented and easier to figure out than the actual
    google-cloud python libs
    """

    # Defaults
    project: str
    quiet: bool = True  # No prompts, accept defaults

    @property
    def config(self) -> dict:
        return dataclasses.asdict(self)

    def __call__(self, *args, _mode='response', **kwargs):

        # Build cmd
        kwargs = {**self.config, **kwargs}  # Silently overwrite duplicate keys with user keys
        if _mode == 'response':
            # So we can parse gcloud result as json (below)
            kwargs = dict(**kwargs, format='json')  # Loudly fail if user passed a 'format' key
        gcloud_cmd = shell_cmd('gcloud', *args, **kwargs)

        # Handle mode
        if _mode == 'exec':
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', 'exec %s' % repro_cmd]
        elif _mode == 'async':
            repro_cmd = '%s >/dev/null 2>/dev/null &' % gcloud_cmd  # TODO Use nohup? [How to prevent nohup.out file?]
            real_cmd = ['bash', '-c', repro_cmd]
        else:
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        print(color('black', f'$ {repro_cmd}'))
        # print(color('red', f'$ {real_cmd}'))  # Debug

        # Run cmd
        if _mode == 'exec':
            # Run, wait for completion, and exit with cmd's exit status
            #   - Passthru fd's (e.g. stdin/stdout/stderr)
            #   - Don't actually exec here since it wouldn't run our atexit handlers (delete instance)
            proc = subprocess.run(real_cmd)
            sys.exit(proc.returncode)
        elif _mode == 'async':
            # Run, ignore result
            #   - Assume cmd is already async via something like bash's '&', from above
            subprocess.run(real_cmd)
        else:
            # Run, wait for completion, parse output (assumes '--format=json', above)
            proc = subprocess.run(real_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Handle result
            if proc.returncode != 0:
                msg = 'Exit %s: %s' % (proc.returncode, re.sub('\n+\s*', ' ', proc.stderr.decode().strip()))
                if proc.stdout:
                    msg += f', stdout[{stdout.decode()}]'
                raise Exception(msg)
            else:
                if proc.stderr:
                    print(color(None, proc.stderr.decode()), end='', file=sys.stderr)
                return json.loads(proc.stdout)


def shell_cmd(*args, _end_args=None, **kwargs) -> str:
    return ' '.join([
        *map(shlex.quote, args),
        *[
            (
                '--%s' % shlex.quote(k) if v == True else
                '--%s=%s' % (shlex.quote(k), shlex.quote(v))
            )
            for k, v in kwargs.items()
            for k in [k.replace('_', '-')]
            if v
        ],
        *map(shlex.quote, (_end_args or [])),
    ])


def retry(f, times: int, delay_s: float):
    attempt = 1
    while True:
        try:
            return f()
        except Exception as e:
            print(color('yellow', f'Retrying[{attempt}/{times}] in {delay_s}s after error: {e}'))
            time.sleep(delay_s)
            attempt += 1
            if attempt > times:
                break


def color(name: str, s: str, **kwargs) -> str:
    kwargs.setdefault('bold', True)  # Bold is great
    return s if not name else getattr(crayons, name)(s, **kwargs)


if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, EOFError):
        pass
