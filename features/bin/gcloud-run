#!/usr/bin/env python
#
# Example auth, e.g. for deploys:
#   GOOGLE_APPLICATION_CREDENTIALS=~/hack/.bubo-secrets/gcloud-service-account-bubo.json bin/gcloud-run ...
#
# Notes for different images:
#   - cos
#       - docker v17 [https://cloud.google.com/container-optimized-os/docs/release-notes]
#   - coreos
#       - docker v18 [https://coreos.com/releases/]
#       - --username=core [https://coreos.com/os/docs/latest/booting-on-google-compute-engine.html]
#       - [I can't get `ssh core@...` to work...]

import atexit
from datetime import datetime, timedelta
import json
import os
from pathlib import Path
import re
import shlex
import subprocess
import sys
import time

from attrdict import AttrDict
import click
import crayons
import dataclasses
from dataclasses import dataclass
from potoo.pretty import pp

# click: Default option(show_default=True)
_click_option = click.option
click.option = lambda *args, **kwargs: _click_option(*args, **{'show_default': True, **kwargs})

code_dir = Path(__file__).parent.parent


# FIXME click doesn't exit nonzero on -h/--help [wat]
#   - https://github.com/pallets/click/issues/702
@click.command(context_settings=dict(
    help_option_names=['-h', '--help'],
    max_content_width=click.get_terminal_size()[0],
))
# Project/zone
@click.option('--project', default='bubo-1')
@click.option('--zone', default='us-west1-b')
# Instance name
@click.option('--instance-name', default='%(instance_name_prefix)s-%(timestamp)s')
@click.option('--instance-name-prefix', default='gcloud-run')
# Machine type
#   - https://cloud.google.com/compute/pricing
#   - Pricing
#                 type  cpu   mem              $/mo            $/d              $/hr
#        n1-standard-4    4   15g  $[  97 /  29]/mo  $[  5 /  1]/d  $[ .19 / .04]/hr
#        n1-standard-8    8   30g  $[ 194 /  58]/mo  $[  9 /  2]/d  $[ .38 / .08]/hr
#       n1-standard-16   16   60g  $[ 388 / 116]/mo  $[ 18 /  4]/d  $[ .76 / .16]/hr
#       n1-standard-32   32  120g  $[ 776 / 233]/mo  $[ 36 /  8]/d  $[1.52 / .32]/hr
#       n1-standard-64   64  240g  $[1553 / 467]/mo  $[ 73 / 16]/d  $[3.04 / .64]/hr
#       n1-standard-96   96  360g  $[2330 / 700]/mo  $[109 / 23]/d  $[4.56 / .96]/hr
@click.option('--machine-type', default='n1-standard-4', help='https://cloud.google.com/compute/pricing')
@click.option('--preemptible/--no-preemptible', default=False)
# Instance lifetime
@click.option('--keep', default=None, help='Instance name to create and keep (no delete)')
@click.option('--reuse', default=None, help='Instance name to reuse (no create, delete, await)')
@click.option('--create-instance/--no-create-instance', default=True)
@click.option('--delete-instance/--no-delete-instance', default=True)
# Image
#   - `gcloud compute images list`
#   - https://cloud.google.com/compute/docs/images
#   - $.085/gb/mo
@click.option('--image-project', default='%(project)s')
@click.option('--image-family', default='bubo-cache')
@click.option('--image', default=None)
# Disks
#   - https://cloud.google.com/compute/docs/disks/
#   - pd-standard
#       - $.04/gb/mo
#       - Throughput r  = max(180, 12*size/100gb) mb/s [max at 1500gb, $60/mo]
#       - Throughput w  = max(120, 12*size/100gb) mb/s [max at 1000gb, $40/mo]
#   - pd-ssd
#       - $.17/gb/mo
#       - Throughput rw = max(240, 48*size/100gb) mb/s
#   - Examples
#       - pd-standard  100gb:  $4/mo,  12mb/s r,  12mb/s w
#       - pd-standard  200gb:  $8/mo,  24mb/s r,  24mb/s w
#       - pd-ssd       100gb: $17/mo,  48mb/s rw
#       - pd-standard  500gb: $20/mo,  60mb/s r,  60mb/s w
#       - pd-standard  750gb: $30/mo,  90mb/s r,  90mb/s w
#       - pd-ssd       200gb: $34/mo,  96mb/s rw
#       - pd-standard 1000gb: $40/mo, 120mb/s r, 120mb/s w
#       - pd-standard 1500gb: $60/mo, 180mb/s r, 120mb/s w
#       - pd-ssd       500gb: $85/mo, 240mb/s rw
@click.option('--boot-disk-size', default='200g')
@click.option('--boot-disk-type', default='pd-standard', help='pd-standard | pd-ssd')
@click.option('--disk-name', default='bubo-data-standard')
@click.option('--disk-mode', default='ro')
@click.option('--disk', default='name=%(disk_name)s,device-name=%(disk_name)s,boot=no,auto-delete=no,mode=%(disk_mode)s')
# Network tier
#   - https://cloud.google.com/network-tiers/pricing
#   - Standard: Egress NA -> *[$.085/gb]
#   - Premium:  Egress NA -> NA[$.105/gb], China[$.46/gb], Oceania[$.19/gb], *[$.12/gb]
#   - Region us-west1 only supports premium
@click.option('--network-tier', default='PREMIUM')
# Service account
#   - By default, gce uses the "Compute Engine default service account" with a limited set of --scopes
#   - This default overrides --scopes to give full access to all gcloud apis
#   - If you want to change the service account, use --service-account or else you'll have to manually `gcloud auth
#     activate-service-account` to override it (and `gcloud auth` takes precedence over GOOGLE_APPLICATION_CREDENTIALS)
@click.option('--service-account', default=None)
@click.option('--scopes', default='https://www.googleapis.com/auth/cloud-platform')
# VM
#   - Can only mount disk here, not also gs [because gcsfuse is too difficult to install into cos...]
#   - TODO Clean up --disk / --vm-init: tight coupling, wouldn't use one without the other
#   - HACK Need bash because cos mounts are noexec (ugh) [https://stackoverflow.com/a/50279396/397334]
@click.option('--vm-init', default='sudo bash vm-bin/mount-disk-bubo-data')
# Container
@click.option('--container/--no-container', default=True, help='Run command in container, else run in instance')
@click.option('--vm/--no-vm', default=False, help='--vm is an alias for --no-container')
@click.option('--container-image', default='gcr.io/%(project)s/bubo/features:latest')
@click.option('--container-name', default='%(instance_name)s')
@click.option('--container-vols', default='-v/mnt/disks/disk-bubo-data:/mnt/disks/disk-bubo-data')
# TODO Clean up this mess
@click.option('--docker-pull', default=' '.join([
    'sudo docker run -it',
    '-v/var/run/docker.sock:/var/run/docker.sock',
    'google/cloud-sdk:203.0.0',
    'bash -c "gcloud auth configure-docker --quiet && docker pull %(container_image)s"',
]))
@click.option('--docker-run', default=' '.join([
    'if sudo docker exec -it %(container_name)s true 2>/dev/null; then',
        'sudo docker exec -it',
        '%(container_name)s',
        '%(command)s',
    '; else',
        '%(docker_pull)s &&',
        'sudo docker run -it',
        '--privileged --restart=no --rm --name=%(container_name)s',
        '%(container_vols)s',
        '%(container_image)s',
        '%(command)s',
    '; fi',
]))
# Command
@click.option('--await-ready/--no-await-ready', default=True)
@click.option('--username', default='bubo')
@click.argument('command', nargs=1, required=False)  # Cmd as a single shell token, i.e. quote the whole thing
def main(
    project, zone,
    instance_name, instance_name_prefix,
    machine_type, preemptible,
    keep, reuse, create_instance, delete_instance,
    image_project, image_family, image,
    boot_disk_size, boot_disk_type, disk_name, disk_mode, disk,
    network_tier,
    service_account, scopes,
    vm_init,
    container, vm, container_image, container_name, container_vols, docker_pull, docker_run,
    await_ready, username, command,
):

    gcloud = GCloud(
        project=project,
    )

    # Args
    #   - TODO Do these substitutions generically so you don't have to manually specify each allowed subst
    instance_name = instance_name % dict(
        instance_name_prefix=instance_name_prefix,
        timestamp=re.sub('[^0-9T]', '-', datetime.utcnow().isoformat()).lower(),
    )
    # TODO Would we want `--keep=x --reuse=x` to mean "assume x exists" (like `--reuse=x`) or "boot x if not exists"?
    assert not (keep and reuse)
    if keep:
        delete_instance = False
        instance_name = keep
    if reuse:
        create_instance = False
        delete_instance = False
        await_ready = False
        instance_name = reuse
    image_project = image_project % dict(project=project)
    if disk:
        disk = disk % dict(disk_name=disk_name, disk_mode=disk_mode)
    if vm:
        container = False
    container_image = container_image % dict(project=project)
    container_name = container_name % dict(instance_name=instance_name)
    if command is None:
        command = 'bash'
    command = 'bash -c %s' % shlex.quote(command)
    docker_pull = docker_pull % dict(
        container_image=shlex.quote(container_image),
    )
    docker_run = docker_run % dict(
        docker_pull=docker_pull,
        container_name=shlex.quote(container_name),
        container_image=shlex.quote(container_image),
        container_vols=shlex.quote(container_vols),
        command=command,
    )

    # Delete instance on exit
    #   - Use atexit so we can exec
    if delete_instance:
        def _atexit():
            gcloud('compute', 'instances', 'delete', instance_name,
                zone=zone,
                _mode='async',
            )
        atexit.register(_atexit)

    # Create instance
    if create_instance:
        print(color('blue', 'Creating instance...'))
        [res] = gcloud('beta', 'compute', 'instances', 'create', instance_name,
            zone=zone,
            machine_type=machine_type,
            preemptible=preemptible,
            image_project=image_project,
            image_family=image_family,
            image=image,
            boot_disk_size=boot_disk_size,
            boot_disk_type=boot_disk_type,
            disk=disk,
            network_tier=network_tier,
            service_account=service_account,
            scopes=scopes,
            # tags='http-server,https-server',  # For ports 80/443
        )
        assert res['name'] == instance_name
        external_ip = res['networkInterfaces'][0]['accessConfigs'][0]['natIP']
        print(color('blue', 'Created instance:'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        print(color('blue', '  external_ip: %s' % external_ip))

    # Wait until ssh'ing into the instance succeeds
    if await_ready:
        print(color('blue', 'Awaiting instance ready...'))
        retry(times=60, delay_s=1, f=lambda: (
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _json=False,
                _end_args=['--', '-tq', 'true'],
            )
        ))
        print(color('blue', 'Instance ready'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        if create_instance:
            print(color('blue', '  external_ip: %s' % external_ip))

    # Run vm_init
    if vm_init and create_instance:

        # rsync vm-bin/ to vm
        cmd = ' '.join([
            '%(code_dir)s/bin/rsync-gcloud',
            '-azv --delete -FF --links --prune-empty-dirs',
            '%(code_dir)s/vm-bin/',
            '%(instance_name)s:vm-bin/',
        ]) % dict(
            code_dir=shlex.quote(str(code_dir)),
            instance_name=shlex.quote(instance_name),
        )
        print(f'$ {cmd}')
        subprocess.run(cmd, shell=True, check=True)

        # Mount (non-boot) disks
        gcloud('compute', 'ssh', f'{username}@{instance_name}',
            zone=zone,
            _json=False,
            _end_args=['--', '-tq', vm_init],
        )

    # Run command
    #   - WARNING Careful with retry here: need to distinguish transient (network) vs. non-transient (command) errors
    if command:
        if not container:
            print(color('blue', f'Running command on instance[{instance_name}]...'))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-tq', command],
            )
        else:
            print(color('blue', 'Running command on %s...' % ' / '.join([
                f'instance[{instance_name}]',
                f'image[{container_image}]',
                f'container[{container_name}]',
            ])))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-tq', ' && '.join(['set -x', docker_run])],
            )


@dataclass
class GCloud:
    """
    A thin wrapper around the gcloud cli, because it's better documented and easier to figure out than the actual
    google-cloud python libs
    """

    # Defaults
    project: str
    quiet: bool = True  # No prompts, accept defaults

    @property
    def config(self) -> dict:
        return dataclasses.asdict(self)

    def __call__(self, *args, _mode='response', _json=True, **kwargs):

        # Build cmd
        kwargs = {**self.config, **kwargs}  # Silently overwrite duplicate keys with user keys
        if _mode == 'response':
            # So we can parse gcloud result as json (below)
            kwargs = dict(**kwargs, format='json')  # Loudly fail if user passed a 'format' key
        gcloud_cmd = shell_cmd('gcloud', *args, **kwargs)

        # Handle mode
        if _mode == 'exec':
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', 'exec %s' % repro_cmd]
        elif _mode == 'async':
            repro_cmd = 'nohup %s >>/var/log/gcloud-run-async.log &' % gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        else:
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        print(color('black', f'$ {repro_cmd}'))
        # print(color('red', f'$ {real_cmd}'))  # Debug

        # Run cmd
        if _mode == 'exec':
            # Run, wait for completion, and exit with cmd's exit status
            #   - Passthru fd's (e.g. stdin/stdout/stderr)
            #   - Don't actually exec here since it wouldn't run our atexit handlers (delete instance)
            proc = subprocess.run(real_cmd)
            sys.exit(proc.returncode)
        elif _mode == 'async':
            # Run, ignore result
            #   - Assume cmd is already async via something like bash's '&', from above
            subprocess.run(real_cmd)
        else:
            # Run, wait for completion, parse output (assumes '--format=json', above)
            proc = subprocess.run(real_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Handle result
            if proc.returncode != 0:
                msg = 'Exit %s: stderr[%s]' % (
                    proc.returncode,
                    re.sub('\n+\s*', ' ', proc.stderr.decode().strip()),
                )
                if proc.stdout:
                    msg += ', stdout[%s]' % (
                        re.sub('\n+\s*', ' ', proc.stdout.decode().strip()),
                    )
                raise Exception(msg)
            else:
                if proc.stderr:
                    print(color(None, proc.stderr.decode()), end='', file=sys.stderr)
                if not _json:
                    return proc.stdout.decode()
                else:
                    try:
                        return json.loads(proc.stdout.decode())
                    except:
                        print(color('red', 'Failed to parse json from stdout[%s]' % proc.stdout))  # TODO Fold into exc msg
                        raise


def shell_cmd(*args, _end_args=None, **kwargs) -> str:
    return ' '.join([
        *map(shlex.quote, args),
        *[
            (
                '--%s' % shlex.quote(k) if v == True else
                '--%s=%s' % (shlex.quote(k), shlex.quote(v))
            )
            for k, v in kwargs.items()
            for k in [k.replace('_', '-')]
            if v
        ],
        *map(shlex.quote, (_end_args or [])),
    ])


def retry(f, times: int, delay_s: float):
    attempt = 1
    while True:
        try:
            return f()
        except Exception as e:
            print(color('yellow', f'Retrying[{attempt}/{times}] in {delay_s}s after error: {e}'))
            time.sleep(delay_s)
            attempt += 1
            if attempt > times:
                break


def color(name: str, s: str, **kwargs) -> str:
    kwargs.setdefault('bold', True)  # Bold is great
    return s if not name else getattr(crayons, name)(s, **kwargs)


if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, EOFError):
        pass
