#!/usr/bin/env python
#
# WARNING Full of hacks
#
# How to launch a vanilla node (e.g. f1-micro):
#   bin/gcloud-run --keep=... --machine-type=... --boot-disk-size=25g --boot-disk-type=pd-standard --disk= --vm-init= --container-init= true
#
# Notes for different images:
#   - cos
#       - docker v17 [https://cloud.google.com/container-optimized-os/docs/release-notes]
#   - coreos
#       - docker v18 [https://coreos.com/releases/]
#       - --username=core [https://coreos.com/os/docs/latest/booting-on-google-compute-engine.html]
#       - [I can't get `ssh core@...` to work...]
#
# Example auth, e.g. for deploys [XXX Out of date]:
#   GOOGLE_APPLICATION_CREDENTIALS=~/hack/.bubo-secrets/gcloud-service-account-bubo.json bin/gcloud-run ...

import atexit
from datetime import datetime, timedelta
import json
import os
from pathlib import Path
import re
import shlex
import subprocess
import sys
import time

from attrdict import AttrDict
import click
import crayons
import dataclasses
from dataclasses import dataclass
from potoo.pretty import pp
from potoo.util import shell

from constants import project, zone

# click: Default option(show_default=True)
_click_option = click.option
click.option = lambda *args, **kwargs: _click_option(*args, **{'show_default': True, **kwargs})

code_dir = Path(__file__).parent.parent.resolve()
bin_dir = code_dir / 'bin'


# FIXME click doesn't exit nonzero on -h/--help [wat]
#   - https://github.com/pallets/click/issues/702
@click.command(context_settings=dict(
    help_option_names=['-h', '--help'],
    max_content_width=click.get_terminal_size()[0],
))
# Project/zone
@click.option('--project', default=project)
@click.option('--zone', default=zone)
# Instance name
@click.option('--instance-name', default='%(instance_name_prefix)s-%(timestamp)s')
@click.option('--instance-name-prefix', default='gcloud-run')
# Machine type
#   - https://cloud.google.com/compute/pricing
#   - Pricing
#                 type  cpu   mem              $/mo            $/d              $/hr
#        n1-standard-4    4   15g  $[  97 /  29]/mo  $[  5 /  1]/d  $[ .19 / .04]/hr
#        n1-standard-8    8   30g  $[ 194 /  58]/mo  $[  9 /  2]/d  $[ .38 / .08]/hr
#       n1-standard-16   16   60g  $[ 388 / 116]/mo  $[ 18 /  4]/d  $[ .76 / .16]/hr
#       n1-standard-32   32  120g  $[ 776 / 233]/mo  $[ 36 /  8]/d  $[1.52 / .32]/hr
#       n1-standard-64   64  240g  $[1553 / 467]/mo  $[ 73 / 16]/d  $[3.04 / .64]/hr
#       n1-standard-96   96  360g  $[2330 / 700]/mo  $[109 / 23]/d  $[4.56 / .96]/hr
@click.option('--machine-type', default='n1-standard-4', help='https://cloud.google.com/compute/pricing')
@click.option('--preemptible/--no-preemptible', default=False)
# Instance lifetime
@click.option('--keep', default=None, help='Instance name to create and keep (no delete)')
@click.option('--reuse', default=None, help='Instance name to reuse (no create, delete, await)')
@click.option('--create-instance/--no-create-instance', default=True)
@click.option('--delete-instance/--no-delete-instance', default=True)
# Image
#   - `gcloud compute images list`
#   - https://cloud.google.com/compute/docs/images
#   - $.085/gb/mo
@click.option('--image-project', default='%(project)s')
@click.option('--image-family', default='bubo-cache')
@click.option('--image', default=None)
# Disks
#   - https://cloud.google.com/compute/docs/disks/
#   - pd-standard
#       - $.04/gb/mo
#       - Throughput r  = max(180, 12*size/100gb) mb/s [max at 1500gb, $60/mo]
#       - Throughput w  = max(120, 12*size/100gb) mb/s [max at 1000gb, $40/mo]
#   - pd-ssd
#       - $.17/gb/mo
#       - Throughput rw = max(240, 48*size/100gb) mb/s
#   - Examples
#       - pd-standard  100gb:  $4/mo,  12mb/s r,  12mb/s w
#       - pd-standard  200gb:  $8/mo,  24mb/s r,  24mb/s w
#       - pd-ssd       100gb: $17/mo,  48mb/s rw
#       - pd-standard  500gb: $20/mo,  60mb/s r,  60mb/s w
#       - pd-standard  750gb: $30/mo,  90mb/s r,  90mb/s w
#       - pd-ssd       200gb: $34/mo,  96mb/s rw
#       - pd-standard 1000gb: $40/mo, 120mb/s r, 120mb/s w
#       - pd-standard 1500gb: $60/mo, 180mb/s r, 120mb/s w
#       - pd-ssd       500gb: $85/mo, 240mb/s rw
@click.option('--boot-disk-size', default='200g')
@click.option('--boot-disk-type', default='pd-standard', help='pd-standard | pd-ssd')
@click.option('--disk-name', default='bubo-data-standard')
@click.option('--disk-mode', default='ro')
@click.option('--disk', default='name=%(disk_name)s,device-name=%(disk_name)s,boot=no,auto-delete=no,mode=%(disk_mode)s')
# Network tier
#   - https://cloud.google.com/network-tiers/pricing
#   - Standard: Egress NA -> *[$.085/gb]
#   - Premium:  Egress NA -> NA[$.105/gb], China[$.46/gb], Oceania[$.19/gb], *[$.12/gb]
#   - Region us-west1 only supports premium
@click.option('--network-tier', default='PREMIUM')
# Service account
#   - By default, gce uses the "Compute Engine default service account" with a limited set of --scopes
#   - This default overrides --scopes to give full access to all gcloud apis
#   - If you want to change the service account, use --service-account or else you'll have to manually `gcloud auth
#     activate-service-account` to override it (and `gcloud auth` takes precedence over GOOGLE_APPLICATION_CREDENTIALS)
@click.option('--service-account', default=None)
@click.option('--scopes', default='https://www.googleapis.com/auth/cloud-platform')
# vm/container
#   - Can only mount disk here, not also gs [because gcsfuse is too difficult to install into cos...]
#   - TODO Clean up --disk / --vm-init: tight coupling, wouldn't use one without the other
#   - HACK Need bash because cos mounts are noexec (ugh) [https://stackoverflow.com/a/50279396/397334]
@click.option('--vm/--no-vm', default=False, help='--vm is an alias for --no-container')
@click.option('--vm-init', default='sudo bash vm-bin/mount-disk-bubo-data')
@click.option('--container/--no-container', default=True, help='Run command in container, else run in instance')
@click.option('--container-init', default='vm-bin/mount-bubo-data-%(disk_mode)s')
@click.option('--container-pull/--no-container-pull', default=False, help='True if creating an instance, else false')
@click.option('--container-push/--no-container-push', default=False)
@click.option('--container-image', default='gcr.io/%(project)s/bubo/features:latest')
@click.option('--container-name', default='%(instance_name)s')
@click.option('--container-vols', default='-v/mnt/disks/disk-bubo-data:/mnt/disks/disk-bubo-data')
@click.option('--container-ports', default='-p8888:8888')  # TODO Expose '8888' as an option (here and below)
# Send container logs to stackdriver
#   - Disabled by default, since ncurses stuff like htop/glances produces a ton of noise
#   - Docs: https://cloud.google.com/community/tutorials/docker-gcplogs-driver
#   - Docs: https://docs.docker.com/config/containers/logging/gcplogs/
#   - Pricing ($.5/gb/mo): https://cloud.google.com/stackdriver/pricing
@click.option('--container-logging/--no-container-logging', default=False)
@click.option('--container-run/--no-container-run', default=True, help='`docker run`')
@click.option('--container-exec/--no-container-exec', default=False, help='`docker exec`')
@click.option('--container-attach/--no-container-attach', default=False, help='`docker attach`')
@click.option('--sync-code/--no-sync-code', default=True, help='rsync code_dir to remote')
# TODO Ugh, clean up this --docker-pull/--docker-run/--docker-exec mess
@click.option('--docker-pull', default=' '.join([
    'sudo docker run -it',
    '-v/var/run/docker.sock:/var/run/docker.sock',
    'google/cloud-sdk:203.0.0',
    'bash -c "gcloud auth configure-docker --quiet && docker pull %(container_image)s"',
]))
@click.option('--docker-build', default=' '.join([
    # TODO Document v18 vs. v17 like docker-build-push-gcloud
    'sudo docker run -it',
    '-v/var/run/docker.sock:/var/run/docker.sock',
    '-v"$PWD"/build:/build',
    '-w/build',
    'docker:18.03.1',
    'docker build . --cache-from=%(container_image)s -t %(container_image)s',
    # 'docker build . -t %(container_image)s',
]))
@click.option('--docker-push', default=' '.join([
    # XXX Unused
    'sudo docker run -it',
    '-v/var/run/docker.sock:/var/run/docker.sock',
    'google/cloud-sdk:203.0.0',
    'bash -c "gcloud auth configure-docker --quiet && docker push %(container_image)s"',
]))
@click.option('--docker-run', default=' '.join([
    # Don't unconditionally pull, since it busts our local cache and we have to rebuild from the pulled image
    #   - And don't unconditionally push, since it slows down our dev loop
    '%(maybe_docker_pull)s &&',
    '%(docker_build)s &&',
    '%(maybe_docker_push)s &&',
    'sudo docker run -it',
    '--privileged --restart=no --rm --name=%(container_name)s -eCONTAINER_NAME=%(container_name)s',
    '%(docker_run_opts)s',
    '%(container_vols)s',
    '%(container_ports)s',
    '%(container_logging)s',
    '%(container_image)s',
    '%(command)s',
]))
@click.option('--docker-run-opts', default=' '.join([
    # Increase /dev/shm 64m -> 10g to avoid "No space left on device" errors from sklearn/joblib
    #   - https://stackoverflow.com/questions/40115043/no-space-left-on-device-error-while-fitting-sklearn-model
    #   - https://github.com/joblib/joblib/issues/168
    '--shm-size=10g',
]))
@click.option('--docker-exec', default=' '.join([
    'sudo docker exec -it',
    '%(container_name)s',
    '%(command)s',
]))
@click.option('--docker-attach', default=' '.join([
    'sudo docker attach',
    '%(container_name)s',
]))
# Command
@click.option('--await-ready/--no-await-ready', default=True)
@click.option('--username', default='bubo')
@click.argument('command', nargs=1, required=False)  # Cmd as a single shell token, i.e. quote the whole thing
def main(
    project, zone,
    instance_name, instance_name_prefix,
    machine_type, preemptible,
    keep, reuse, create_instance, delete_instance,
    image_project, image_family, image,
    boot_disk_size, boot_disk_type, disk_name, disk_mode, disk,
    network_tier,
    service_account, scopes,
    vm, vm_init,
    container, container_init, container_pull, container_push,
    container_image, container_name, container_vols, container_ports, container_logging,
    container_run, container_exec, container_attach, sync_code,
    docker_pull, docker_build, docker_push, docker_run, docker_run_opts, docker_exec, docker_attach,
    await_ready, username, command,
):

    gcloud = GCloud(
        project=project,
    )

    # Args
    #   - TODO Do these substitutions generically so you don't have to manually specify each allowed subst
    instance_name = instance_name % dict(
        instance_name_prefix=instance_name_prefix,
        timestamp=re.sub('[^0-9T]', '-', datetime.utcnow().isoformat()).lower(),
    )
    # TODO Would we want `--keep=x --reuse=x` to mean "assume x exists" (like `--reuse=x`) or "boot x if not exists"?
    assert not (keep and reuse)
    if keep:
        delete_instance = False
        instance_name = keep
    if reuse:
        create_instance = False
        delete_instance = False
        await_ready = False
        instance_name = reuse
    image_project = image_project % dict(project=project)
    if disk:
        disk = disk % dict(disk_name=disk_name, disk_mode=disk_mode)
    container_init = container_init % dict(disk_mode=disk_mode)
    if vm:
        container = False
    container_pull = container_pull or create_instance  # Always pull if the instance is fresh
    container_image = container_image % dict(project=project)
    container_name = container_name % dict(instance_name=instance_name)
    container_logging = '--log-driver=gcplogs' if container_logging else ''
    container_op = (
        'attach' if container_attach else
        'exec' if container_exec else
        'run'
    )
    assert not sync_code or container_op in ['run', 'exec']
    if not command:
        command = 'bash'
    command = command % dict(instance_name=instance_name)
    if container and container_op == 'run' and container_init:
        command = ' && '.join([container_init, command])
    command = 'bash -x -c %s' % shlex.quote(command)
    docker_pull = docker_pull % dict(
        container_image=shlex.quote(container_image),
    )
    docker_build = docker_build % dict(
        container_image=shlex.quote(container_image),
    )
    docker_push = docker_push % dict(
        container_image=shlex.quote(container_image),
    )
    docker_run = docker_run % dict(
        maybe_docker_pull=docker_pull if container_pull else ':',
        docker_build=docker_build,
        maybe_docker_push=docker_push if container_push else ':',
        container_name=shlex.quote(container_name),
        docker_run_opts=docker_run_opts,
        container_vols=container_vols,
        container_ports=container_ports,
        container_logging=container_logging,
        container_image=shlex.quote(container_image),
        command=command,
    )
    docker_exec = docker_exec % dict(
        container_name=shlex.quote(container_name),
        command=command,
    )
    docker_attach = docker_attach % dict(
        container_name=shlex.quote(container_name),
        command=command,
    )

    # Delete instance on exit
    #   - Use atexit so we can exec
    if delete_instance:
        def _atexit():
            gcloud('compute', 'instances', 'delete', instance_name,
                zone=zone,
                _mode='async',
            )
        atexit.register(_atexit)

    # Create instance
    if create_instance:
        print(color('blue', 'Creating instance...'))
        [res] = gcloud('beta', 'compute', 'instances', 'create', instance_name,
            zone=zone,
            machine_type=machine_type,
            preemptible=preemptible,
            image_project=image_project,
            image_family=image_family,
            image=image,
            boot_disk_size=boot_disk_size,
            boot_disk_type=boot_disk_type,
            disk=disk,
            network_tier=network_tier,
            service_account=service_account,
            scopes=scopes,
            # tags='http-server,https-server',  # For ports 80/443
        )
        assert res['name'] == instance_name
        external_ip = res['networkInterfaces'][0]['accessConfigs'][0]['natIP']
        print(color('blue', 'Created instance:'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        print(color('blue', '  external_ip: %s' % external_ip))

    # Wait until ssh'ing into the instance succeeds
    if await_ready:
        print(color('blue', 'Awaiting instance ready...'))
        retry(times=60, delay_s=1, f=lambda: (
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='no-json',
                _end_args=['--', '-tq', 'true'],
            )
        ))
        print(color('blue', 'Instance ready'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        if create_instance:
            print(color('blue', '  external_ip: %s' % external_ip))

    # Run vm_init
    if create_instance and vm_init:

        print(color('blue', f'Syncing vm-bin/ to instance[{instance_name}]...'))
        shell(
            '%(bin_dir)s/rsync-vm %(code_dir)s/vm-bin/ %(instance_name)s:vm-bin/',
            bin_dir=bin_dir,
            code_dir=code_dir,
            instance_name=instance_name,
        )

        print(color('blue', f'Running --vm-init'))
        gcloud('compute', 'ssh', f'{username}@{instance_name}',
            zone=zone,
            _mode='no-json',
            _end_args=['--', '-tq', vm_init],
        )

    # Run command
    #   - WARNING Careful with retry here: need to distinguish transient (network) vs. non-transient (command) errors
    if command:

        # Run cmd in vm
        if not container:
            print(color('blue', f'Running command on instance[{instance_name}]...'))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-tq', command],
            )
        else:

            # Sync code (to container)
            if sync_code:
                print(color('blue', 'Syncing code_dir[%s] to container on %s...' % (code_dir, ' / '.join([
                    f'instance[{instance_name}]', f'image[{container_image}]', f'container[{container_name}]',
                ]))))

                # If docker run, then rsync-vm
                if container_op == 'run':
                    shell(
                        '%(bin_dir)s/rsync-vm %(code_dir)s/ %(instance_name)s:build/',
                        bin_dir=bin_dir,
                        code_dir=code_dir,
                        instance_name=instance_name,
                    )

                # If docker exec, then rsync-container
                elif container_op == 'exec':
                    assert container_name == instance_name, 'TODO Add --container to bin/rsync-container (env var?)'
                    shell(
                        '%(bin_dir)s/rsync-code-to-container %(instance_name)s',
                        bin_dir=bin_dir,
                        instance_name=instance_name,
                    )

            # Run cmd via docker run/exec, or just docker attach
            print(color('blue', 'Running command on %s...' % ' / '.join([
                f'instance[{instance_name}]', f'image[{container_image}]', f'container[{container_name}]',
            ])))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=[
                    '--',
                    '-tq',
                    '-L', '8888:localhost:8888',  # Tunnel port 8888
                    docker_attach if container_op == 'attach' else
                        docker_exec if container_op == 'exec' else
                        docker_run,
                ],
            )


@dataclass
class GCloud:
    """
    A thin wrapper around the gcloud cli, because it's better documented and easier to figure out than the actual
    google-cloud python libs
    """

    # Defaults
    project: str
    quiet: bool = True  # No prompts, accept defaults

    @property
    def config(self) -> dict:
        return dataclasses.asdict(self)

    def __call__(self, *args, _mode='json', **kwargs):
        assert _mode in ['json', 'no-json', 'exec', 'async']

        # Build cmd
        kwargs = {**self.config, **kwargs}  # Silently overwrite duplicate keys with user keys
        if _mode == 'response':
            # So we can parse gcloud result as json (below)
            kwargs = dict(**kwargs, format='json')  # Loudly fail if user passed a 'format' key
        gcloud_cmd = shell_cmd('gcloud', *args, **kwargs)

        # Handle mode
        if _mode == 'exec':
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', 'exec %s' % repro_cmd]
        elif _mode == 'async':
            repro_cmd = 'nohup %s >>/var/log/gcloud-run-async.log &' % gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        else:
            repro_cmd = ('%s --format=json' if _mode == 'json' else '%s') % gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        print(color('black', f'$ {repro_cmd}'))
        # print(color('red', f'$ {real_cmd}'))  # Debug

        # Run cmd
        if _mode == 'exec':
            # Run, wait for completion, and exit with cmd's exit status
            #   - Passthru fd's (e.g. stdin/stdout/stderr)
            #   - Don't actually exec here since it wouldn't run our atexit handlers (delete instance)
            proc = subprocess.run(real_cmd)
            sys.exit(proc.returncode)
        elif _mode == 'async':
            # Run, ignore result
            #   - Assume cmd is already async via something like bash's '&', from above
            subprocess.run(real_cmd)
        else:
            # Run, wait for completion, parse output (assumes '--format=json', above)
            proc = subprocess.run(
                real_cmd,
                stdout=subprocess.PIPE if _mode == 'json' else None,
            )

            # Handle result
            if proc.returncode != 0:
                msg = 'Process exited %s' % proc.returncode
                if proc.stdout:
                    msg += ', stdout[%s]' % (
                        re.sub('\n+\s*', ' ', proc.stdout.decode().strip()),
                    )
                raise Exception(msg)
            elif _mode == 'json':
                try:
                    return json.loads(proc.stdout.decode())
                except:
                    print(color('red', 'Failed to parse json from stdout[%s]' % proc.stdout))  # TODO Fold into exc msg
                    raise


def shell_cmd(*args, _end_args=None, **kwargs) -> str:
    return ' '.join([
        *map(shlex.quote, args),
        *[
            (
                '--%s' % shlex.quote(k) if v == True else
                '--%s=%s' % (shlex.quote(k), shlex.quote(v))
            )
            for k, v in kwargs.items()
            for k in [k.replace('_', '-')]
            if v
        ],
        *map(shlex.quote, (_end_args or [])),
    ])


def retry(f, times: int, delay_s: float):
    attempt = 1
    while True:
        try:
            return f()
        except Exception as e:
            print(color('yellow', f'Retrying[{attempt}/{times}] in {delay_s}s after error: {e}'))
            time.sleep(delay_s)
            attempt += 1
            if attempt > times:
                break


def color(name: str, s: str, **kwargs) -> str:
    kwargs.setdefault('bold', True)  # Bold is great
    if not name or not sys.stdout.isatty():
        return s
    else:
        return getattr(crayons, name)(s, **kwargs)


if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, EOFError):
        pass
