#!/usr/bin/env python
#
# Example auth, e.g. for deploys:
#   GOOGLE_APPLICATION_CREDENTIALS=~/hack/.bubo-secrets/gcloud-service-account-bubo.json bin/gcloud-run ...
#
# Notes for different images:
#   - cos
#       - docker v17 [https://cloud.google.com/container-optimized-os/docs/release-notes]
#   - coreos
#       - docker v18 [https://coreos.com/releases/]
#       - --username=core [https://coreos.com/os/docs/latest/booting-on-google-compute-engine.html]
#       - [I can't get `ssh core@...` to work...]

import atexit
from datetime import datetime, timedelta
import json
import os
import re
import shlex
import subprocess
import sys
import time

from attrdict import AttrDict
import click
import crayons
import dataclasses
from dataclasses import dataclass
from potoo.pretty import pp


# click: Default option(show_default=True)
_click_option = click.option
click.option = lambda *args, **kwargs: _click_option(*args, **{'show_default': True, **kwargs})


# FIXME click doesn't exit nonzero on -h/--help [wat]
#   - https://github.com/pallets/click/issues/702
@click.command(context_settings=dict(
    help_option_names=['-h', '--help'],
    max_content_width=click.get_terminal_size()[0],
))
# Project/zone
@click.option('--project', default='bubo-1')
@click.option('--zone', default='us-west1-b')
# Instance name
@click.option('--instance-name', default=None, help='Defaults to: "<instance-name-prefix>-<timestamp>"')
@click.option('--instance-name-prefix', default='gcloud-run')
# Machine type
#   - https://cloud.google.com/compute/pricing
@click.option('--machine-type', default='n1-standard-4', help='https://cloud.google.com/compute/pricing')
@click.option('--preemptible/--no-preemptible', default=False)
# Instance lifetime
@click.option('--reuse', default=None, help='Instance name to reuse (no create, delete, await)')
@click.option('--keep', default=None, help='Instance name to create and keep (no delete)')
@click.option('--create-instance/--no-create-instance', default=True)
@click.option('--delete-instance/--no-delete-instance', default=True)
# Image
#   - `gcloud compute images list`
#   - https://cloud.google.com/compute/docs/images
@click.option('--image-project', default='cos-cloud')
@click.option('--image-family', default='cos-stable')
@click.option('--image', default=None)
# Boot disk
#   - https://cloud.google.com/compute/docs/disks/
@click.option('--boot-disk-size', default='200g')
@click.option('--boot-disk-type', default='pd-standard')
# Network tier
#   - https://cloud.google.com/network-tiers/pricing
#   - Standard: Egress NA -> *[$.085/gb]
#   - Premium:  Egress NA -> NA[$.105/gb], China[$.46/gb], Oceania[$.19/gb], *[$.12/gb]
#   - Region us-west1 only supports premium
@click.option('--network-tier', default='PREMIUM')
# Service account
#   - By default, gce uses the "Compute Engine default service account" with a limited set of --scopes
#   - This default overrides --scopes to give full access to all gcloud apis
#   - If you want to change the service account, use --service-account or else you'll have to manually `gcloud auth
#     activate-service-account` to override it (and `gcloud auth` takes precedence over GOOGLE_APPLICATION_CREDENTIALS)
@click.option('--service-account', default=None)
@click.option('--scopes', default='https://www.googleapis.com/auth/cloud-platform')
# Container
@click.option('--container-image', default=None, help='Run command in container if given, else run in the instance')
@click.option('--container-name', default=None, help='Defaults to instance_name')
@click.option('--docker-pull', default='sudo docker pull')
@click.option('--docker-run', default='sudo docker run -it --privileged --restart=no --rm')
# Command
@click.option('--await-ready/--no-await-ready', default=True)
@click.option('--username', default='bubo')
@click.argument('command', nargs=1, required=False)  # One cmd string, e.g. quoted by the user
def main(
    project, zone,
    instance_name, instance_name_prefix,
    machine_type, preemptible,
    reuse, keep, create_instance, delete_instance,
    image_project, image_family, image,
    boot_disk_size, boot_disk_type,
    network_tier,
    service_account, scopes,
    container_image, container_name, docker_pull, docker_run,
    await_ready, username, command,
):

    gcloud = GCloud(
        project=project,
    )

    # Args
    instance_name = instance_name or '%s-%s' % (
        instance_name_prefix,
        re.sub('[^0-9T]', '-', datetime.utcnow().isoformat()).lower(),
    )
    if reuse:
        create_instance = False
        delete_instance = False
        await_ready = False
        instance_name = reuse
    if keep:
        delete_instance = False
        instance_name = keep
    if command is None:
        command = 'bash'

    # Delete instance on exit
    #   - Use atexit so we can exec
    if delete_instance:
        def _atexit():
            gcloud('compute', 'instances', 'delete', instance_name,
                zone=zone,
                _mode='async',
            )
        atexit.register(_atexit)

    # Create instance
    if create_instance:
        print(color('blue', 'Creating instance...'))
        [res] = gcloud('beta', 'compute', 'instances', 'create', instance_name,
            zone=zone,
            machine_type=machine_type,
            preemptible=preemptible,
            image_project=image_project,
            image_family=image_family,
            image=image,
            boot_disk_size=boot_disk_size,
            boot_disk_type=boot_disk_type,
            network_tier=network_tier,
            service_account=service_account,
            scopes=scopes,
            # tags='http-server,https-server',  # For ports 80/443
        )
        assert res['name'] == instance_name
        external_ip = res['networkInterfaces'][0]['accessConfigs'][0]['natIP']
        print(color('blue', 'Created instance:'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        print(color('blue', '  external_ip: %s' % external_ip))

    # Wait until ssh'ing into the instance succeeds
    if await_ready:
        print(color('blue', 'Awaiting instance ready...'))
        retry(times=60, delay_s=1, f=lambda: (
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _end_args=['--', '-tq', 'true'],
            )
        ))
        print(color('blue', 'Instance ready'))
        print(color('blue', '  zone: %s' % zone))
        print(color('blue', '  instance_name: %s' % instance_name))
        if create_instance:
            print(color('blue', '  external_ip: %s' % external_ip))

    # Run command via ssh
    #   - WARNING Careful with retry here: need to distinguish transient (network) vs. non-transient (command) errors
    if command:
        command = 'bash -c %s' % shlex.quote(command)
        if not container_image:
            print(color('blue', f'Running command on instance[{instance_name}]...'))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-tq', command],
            )
        else:
            container_name = container_name or instance_name
            print(color('blue', 'Running command on %s...' % ' / '.join([
                f'instance[{instance_name}]',
                f'image[{container_image}]',
                f'container[{container_name}]',
            ])))
            gcloud('compute', 'ssh', f'{username}@{instance_name}',
                zone=zone,
                _mode='exec',
                _end_args=['--', '-tq', ' '.join([
                    'set -x &&',
                    docker_pull,
                    shlex.quote(container_image),
                    '&&',
                    docker_run,
                    '--name=%s' % shlex.quote(container_name),
                    shlex.quote(container_image),
                    command,
                ])],
            )


@dataclass
class GCloud:
    """
    A thin wrapper around the gcloud cli, because it's better documented and easier to figure out than the actual
    google-cloud python libs
    """

    # Defaults
    project: str
    quiet: bool = True  # No prompts, accept defaults

    @property
    def config(self) -> dict:
        return dataclasses.asdict(self)

    def __call__(self, *args, _mode='response', **kwargs):

        # Build cmd
        kwargs = {**self.config, **kwargs}  # Silently overwrite duplicate keys with user keys
        if _mode == 'response':
            # So we can parse gcloud result as json (below)
            kwargs = dict(**kwargs, format='json')  # Loudly fail if user passed a 'format' key
        gcloud_cmd = shell_cmd('gcloud', *args, **kwargs)

        # Handle mode
        if _mode == 'exec':
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', 'exec %s' % repro_cmd]
        elif _mode == 'async':
            repro_cmd = '%s >/dev/null 2>/dev/null &' % gcloud_cmd  # TODO Use nohup? [How to prevent nohup.out file?]
            real_cmd = ['bash', '-c', repro_cmd]
        else:
            repro_cmd = gcloud_cmd
            real_cmd = ['bash', '-c', repro_cmd]
        print(color('black', f'$ {repro_cmd}'))
        # print(color('red', f'$ {real_cmd}'))  # Debug

        # Run cmd
        if _mode == 'exec':
            # Run, wait for completion, and exit with cmd's exit status
            #   - Passthru fd's (e.g. stdin/stdout/stderr)
            #   - Don't actually exec here since it wouldn't run our atexit handlers (delete instance)
            proc = subprocess.run(real_cmd)
            sys.exit(proc.returncode)
        elif _mode == 'async':
            # Run, ignore result
            #   - Assume cmd is already async via something like bash's '&', from above
            subprocess.run(real_cmd)
        else:
            # Run, wait for completion, parse output (assumes '--format=json', above)
            proc = subprocess.run(real_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # Handle result
            if proc.returncode != 0:
                msg = 'Exit %s: %s' % (proc.returncode, re.sub('\n+\s*', ' ', proc.stderr.decode().strip()))
                if proc.stdout:
                    msg += f', stdout[{stdout.decode()}]'
                raise Exception(msg)
            else:
                if proc.stderr:
                    print(color(None, proc.stderr.decode()), end='', file=sys.stderr)
                return json.loads(proc.stdout)


def shell_cmd(*args, _end_args=None, **kwargs) -> str:
    return ' '.join([
        *map(shlex.quote, args),
        *[
            (
                '--%s' % shlex.quote(k) if v == True else
                '--%s=%s' % (shlex.quote(k), shlex.quote(v))
            )
            for k, v in kwargs.items()
            for k in [k.replace('_', '-')]
            if v
        ],
        *map(shlex.quote, (_end_args or [])),
    ])


def retry(f, times: int, delay_s: float):
    attempt = 1
    while True:
        try:
            return f()
        except Exception as e:
            print(color('yellow', f'Retrying[{attempt}/{times}] in {delay_s}s after error: {e}'))
            time.sleep(delay_s)
            attempt += 1
            if attempt > times:
                break


def color(name: str, s: str, **kwargs) -> str:
    kwargs.setdefault('bold', True)  # Bold is great
    return s if not name else getattr(crayons, name)(s, **kwargs)


if __name__ == '__main__':
    try:
        main()
    except (KeyboardInterrupt, EOFError):
        pass
