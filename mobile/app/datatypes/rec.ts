import { EventEmitter } from 'fbemitter';
import _ from 'lodash';
import RNFB from 'rn-fetch-blob';
const {fs} = RNFB;

import {
  DraftEdit, Edit, matchSource, SearchRecs, Source, SourceId, UserMetadata, UserSource, XCSource,
} from 'app/datatypes';
import { debug_print, Log, rich } from 'app/log';
import { NativeSpectro } from 'app/native/Spectro';
import { NativeTagLib } from 'app/native/TagLib';
import { Places } from 'app/places';
import {
  assert, basename, chance, ensureDir, ensureParentDir, extname, ifEmpty, ifError, ifNil, ifNull, ifUndefined, json,
  jsonSafeError, JsonSafeNumber, Interval, local, mapEmpty, mapNil, mapNull, mapUndefined, match, matchError, matchNull,
  matchUndefined, NoKind, Omit, parseDate, parseUrl, parseUrlNoQuery, parseUrlWithQuery, pretty, qsSane,
  requireSafePath, safeParseInt, safeParseIntOrNull, safePath, showDate, showSuffix, splitFirst, stringifyDate,
  stripExt, throw_, tryElse, typed, unjson,
} from 'app/utils';

// TODO How to prevent callers from constructing a Rec i/o one of the subtypes? [Maybe classes with constructors?]
export type Rec = XCRec | UserRec;

export interface XCRec extends _RecImpl {
  // kind:   'xc';     // TODO Requires new-ing our own XCRec objects i/o (unsafely) casting them from sqlite rows
  xc_id:  number;
  // source: XCSource; // TODO Requires new-ing our own XCRec objects i/o (unsafely) casting them from sqlite rows
}

export interface UserRec extends _RecImpl {
  kind:    'user';
  f_preds: Array<number>;
  source:  UserSource
}

export interface _RecImpl {

  // bubo
  source_id: SourceId; // More appropriate than id for mobile (see python util.rec_to_source_id for details)
  // id: string;       // Hide so that we don't accidentally use it (so that we'll get type errors if we try)
  duration_s: number;

  // xc
  species:               string; // (From ebird)
  species_taxon_order:   string; // (From ebird)
  species_species_group: string; // (From ebird)
  species_family:        string; // (From ebird)
  species_order:         string; // (From ebird)
  species_com_name:      string; // (From xc)
  species_sci_name:      string; // (From xc)
  recs_for_sp:           number;
  quality:               Quality;
  lat?:                  number;
  lng?:                  number;
  date:                  string; // sqlite datetime
  month_day:             string; // sqlite string
  year:                  number; // sqlite bigint
  place:                 string;
  place_only:            string;
  state:                 string;
  state_only:            string;
  recordist:             string;
  license_type:          string;
  remarks:               string;

  // HACK Provided only from SearchScreen.loadRecsFromQuery -> rec case
  //  - TODO Split out SearchRecResult for /rec, separate from both query_rec and search results for /species, /random, etc.
  slp?:  number;
  d_pc?: number;

}

export type Quality = 'A' | 'B' | 'C' | 'D' | 'E' | 'no score';
export type F_Preds = Array<number>;

export const Quality = {
  values: ['A', 'B', 'C', 'D', 'E', 'no score'] as Array<Quality>,
};

export function matchRec<X>(rec: Rec, cases: {
  xc:   (rec: XCRec, source: XCSource) => X, // TODO Remove source after we add XCRec.source
  user: (rec: UserRec)                 => X,
}): X {
  // TODO Clean up (default: -> case 'xc':) after we add XCRec.kind
  switch (_.get(rec, 'kind')) {
    case 'user': return cases.user(rec as UserRec); // HACK Type (safe)
    default:     return cases.xc(
      rec as XCRec,   // HACK Type (safe if XCRec is the only Rec where rec.kind !== 'user')
      Source.parseOrFail(rec.source_id, {
        userMetadata: null as unknown as UserMetadata // HACK Safe b/c unused for xc sourceId
      }) as XCSource, // HACK Type (safe if rec.kind agrees with rec.source_id)
    );
  }
}

export interface Rec_f_preds {
  [key: string]: number;
}

export interface SpectroPathOpts {
  f_bins:  number;
  denoise: boolean;
}

export const Rec = {

  log: new Log('Rec'),

  // Primary storage (DocumentDir)
  userRecDir:      `${fs.dirs.DocumentDir}/Recordings`, // User recordings
  // Files that can be regenerated by need (CacheDir)
  spectroCacheDir: `${fs.dirs.CacheDir}/spectros-v0`, // Spectros will recreate if missing

  // Back compat: migrate old-style {user-recs-v0,edits-v0}/ dirs to new-style Recordings/ dir
  //  - XXX(unify_edit_user_recs): After all (three) active users have migrated
  //  - (Used by App.componentDidMount)
  old_userRecDir:  `${fs.dirs.DocumentDir}/user-recs-v0`,
  old_editDir:     `${fs.dirs.DocumentDir}/edits-v0`,
  trash_editDir:   `${fs.dirs.DocumentDir}/_trash_edits-v0`,

  // Events
  emitter: new EventEmitter(),

  // XXX Simplify Rec.source(rec) -> rec.source after we add XCRec.source
  source: (rec: Rec): Source => {
    return matchRec<Source>(rec, {
      xc:   (rec, source) => source,
      user: rec           => rec.source,
    });
  },

  audioPath: (rec: Rec): string => matchRec(rec, {
    xc:   rec => XCRec.audioPath(rec),
    user: rec => UserRec.audioPath(rec.source),
  }),

  spectroPath: (
    rec:  Rec,
    opts: SpectroPathOpts, // Ignored for xc rec [TODO Clean up]
  ): string => matchRec(rec, {
    xc:   rec => XCRec.spectroPath(rec),
    user: rec => UserRec.spectroPath(rec.source, opts),
  }),

  // A writable spectroCachePath for nonstandard f_bins/denoise
  //  - HACK Shared across UserRec.spectroPath + RecordScreen:EditRecording
  //    - EditRecording can't use UserRec.spectroPath because it assumes a user sourceId
  //    - EditRecording can't use Rec.spectroPath because it maps xc sourceIds to their static asset spectroPath (40px)
  //    - TODO Add concept for "writable spectroPath for user/xc rec"
  spectroCachePath: (source: Source, opts: SpectroPathOpts): string => {
    return [
      `${Rec.spectroCacheDir}`,
      `${Source.pathBasename(source)}.spectros`,
      `f_bins=${opts.f_bins},denoise=${opts.denoise}.png`,
    ].join('/');
  },

  // Load metadata from audio file comment tag (as json)
  //  - Version so we can maintain back compat with data from previous code versions
  readMetadata: async (audioPath: string): Promise<null | {
    version:  number,
    metadata: {},
  }> => {
    const commentTag = await NativeTagLib.readComment(audioPath);
    return matchError(() => unjson(commentTag || 'null'), {
      error: e => {
        Rec.log.warn('readMetadata: Ignoring malformed json', pretty({audioPath, commentTag}));
        return null;
      },
      x: versionedMetadata => {
        Rec.log.debug('readMetadata', rich({audioPath, versionedMetadata}));
        return versionedMetadata;
      },
    });
  },

  // Write metadata to audio file comment tag (as json)
  //  - Version so we can maintain back compat with data from previous code versions
  writeMetadata: async (audioPath: string, versionedMetadata: {
    version:  number,
    metadata: {},
  }): Promise<void> => {
    Rec.log.debug('writeMetadata', rich({audioPath, versionedMetadata}));
    await NativeTagLib.writeComment(audioPath, json(versionedMetadata));
  },

  f_preds: (rec: Rec): Rec_f_preds => {
    return matchRec(rec, {
      xc:   rec => rec as unknown as Rec_f_preds,                               // Expose .f_preds_* from sqlite
      user: rec => _.fromPairs(rec.f_preds.map((p, i) => [`f_preds_${i}`, p])), // Materialize {f_preds_*:p} from .f_preds
    });
  },

  hasCoords: (rec: Rec): boolean => {
    return !_.isNil(rec.lat) && !_.isNil(rec.lng);
  },

  placeNorm: (placeLike: string): string => {
    return placeLike.split(', ').reverse().map(x => Rec.placePartAbbrev(x)).join(', ');
  },
  placePartAbbrev: (part: string): string => {
    const ret = (
      Places.countryCodeFromName[part] ||
      Places.stateCodeFromName[part] ||
      part
    );
    return ret;
  },

  recUrl: (rec: Rec): string | null => {
    return matchRec(rec, {
      xc:   rec => XCRec.recUrl(rec),
      user: rec => null, // TODO Get url from parent, for edit recs
    });
  },

  speciesUrl: (rec: Rec): string => {
    return `https://www.allaboutbirds.org/guide/${rec.species_com_name.replace(/ /g, '_')}`;
  },

  // TODO Open in user's preferred map app i/o google maps
  //  - Docs for zoom levels: https://developers.google.com/maps/documentation/maps-static/dev-guide#Zoomlevels
  mapUrl: (rec: Rec, opts: {zoom: number}): string | null => {
    if (!Rec.hasCoords(rec)) {
      // TODO How to zoom when we don't know (lat,lng)?
      const {place} = rec;
      return `https://maps.google.com/maps?oi=map&q=${place}`;
    } else {
      // TODO How to show '$place' as label instead of '$lat,$lng'?
      const {lat, lng, place} = rec;
      const {zoom} = opts;
      return `https://www.google.com/maps/place/${lat},${lng}/@${lat},${lng},${zoom}z`;
    }
  },

};

export const XCRec = {

  pathBasename: (source: XCSource): string => {
    return safePath(Source.stringify(source)); // e.g. 'xc-1234'
  },

  audioPath: (rec: XCRec): string => {
    return SearchRecs.assetPath('audio', rec.species, rec.xc_id, 'mp4');
  },

  spectroPath: (rec: XCRec): string => {
    // From assets, not spectroCacheDir
    return SearchRecs.assetPath('spectro', rec.species, rec.xc_id, 'png');
  },

  // TODO (When needed)
  // sourceFromAudioPath: async (audioPath: string): Promise<XCSource | null> => {
  //   ...
  // },

  recUrl: (rec: XCRec): string => {
    return `https://www.xeno-canto.org/${rec.xc_id}`;
  },

};

export const UserRec = {

  log: new Log('UserRec'),

  audioDir: Rec.userRecDir,

  // Give user rec files a proper audio file ext, else e.g. ios AKAudioFile(forReading:) fails to infer the filetype
  //  - Use .wav to match kAudioFormatLinearPCM in NativeSpectro.create
  audioExt: 'wav',

  pathBasename: (source: UserSource): string => {
    return stripExt(source.filename); // e.g. 'user-20190109205640977-336b2bb7'
  },

  audioPath: (source: UserSource): string => {
    // Use preserved filename so we can roundtrip outdated filename formats (e.g. saved user recs from old code versions)
    const ssp = source.filename;
    return UserRec._audioPathFromSsp(ssp);
  },

  // (Callers: audioPath, load)
  _audioPathFromSsp: (ssp: string): string => {
    return `${UserRec.audioDir}/${ssp}`;
  },

  spectroPath: (source: UserSource, opts: SpectroPathOpts): string => {
    return Rec.spectroCachePath(source, opts);
  },

  // Load user metadata
  //  - TODO(cache_user_metadata): Add cache read/write/invalidate (currently just a passthru to readMetadata)
  //    1. Try reading from cache (AsyncStorage)
  //    2. Else readMetadata (from audio file tags) and write to cache (AsyncStorage)
  //    -  Add invalidation logic in writeMetadata
  loadMetadata: async (audioPath: string): Promise<UserMetadata> => {
    // TODO(cache_user_metadata): Measure perf prior to caching -- the complexity/perf tradeoffs aren't a clear win
    //  - Complexity: AsyncStorage will fail >6mb on android [https://github.com/facebook/react-native/issues/3387]
    //  - Perf: is AsyncStorage actually faster than cache files? [https://facebook.github.io/react-native/docs/asyncstorage]
    //  - Perf: and are cache files actually faster than reading the tags from the audio files?
    return UserRec.readMetadata(audioPath);
  },

  // Read user metadata from audio file tags
  readMetadata: async (audioPath: string): Promise<UserMetadata> => {

    // Compute useful defaults, in case this file doesn't have tags
    //  - e.g. an old file before we started writing tags
    //  - e.g. an imported file that we didn't create
    const defaults = local<UserMetadata>(() => {
      const {ssp} = SourceId.split(UserRec.sourceIdFromAudioPath(audioPath));
      const {created, uniq} = matchError(() => UserSource._maybeParseCreatedUniq(ssp), {
        // If we need default {created,uniq} values, try parsing them from the filename
        x: ({created, uniq}) => ({
          created,
          uniq,
        }),
        // And if the filename isn't our standard format (e.g. renamed by user), then provide sane defaults for the defaults
        error: () => ({
          created: new Date(0),
          uniq:    basename(audioPath),
          // uniq: sha1hex(basename(audioPath)), // TODO Useful? If so, add react-native-crypto (see utils.ts)
        }),
      })
      return {
        created,
        uniq,
        edit:    null,              // Not an edit of another rec
        creator: null,              // Unknown creator
        coords:  null,              // Unknown gps
        species: {kind: 'unknown'}, // Unknown species
      };
    });

    // Read metadata from file
    const versionedMetadata = await Rec.readMetadata(audioPath);
    if (!versionedMetadata) {
      // Noisy (when lots of pre-metadata user recs, e.g. mine)
      // UserRec.log.warn('readMetadata: No metadata (in tags), returning defaults', pretty({
      //   audioPath, versionedMetadata, defaults,
      // }));
      return defaults; // TODO(cache_user_metadata): writeMetadata here? Else we need to ensure deterministic {created,uniq}
    } else {
      const {version, metadata} = versionedMetadata;
      if (version === 1) {
        return ifError(() => UserMetadata.unjsonSafe(metadata), e => {
          UserRec.log.warn('readMetadata: Invalid metadata (in tags), returning defaults', pretty({
            e: jsonSafeError(e), audioPath, versionedMetadata, defaults,
          }));
          return defaults; // (Don't writeMetadata here, else one code bug could wipe out all of a user's file metadata)
        });
      } else {
        throw `UserRec.readMetadata: Unknown version[${version}] for metadata[${metadata}]`;
      }
    }

  },

  // Write user metadata to audio file tags
  //  - TODO(cache_user_metadata): Invalidate/update cache (AsyncStorage)
  writeMetadata: async (audioPath: string, metadata: UserMetadata): Promise<void> => {
    await Rec.writeMetadata(audioPath, {
      version:  1,
      metadata: UserMetadata.jsonSafe(metadata),
    });
  },

  // (Callers: RecordScreen.stopRecording)
  //  - Assumes file at audioPath exists (created by RecordScreen.startRecording -> NativeSpectro)
  new: async (audioPath: string, metadata: UserMetadata): Promise<UserSource> => {

    // Write user metadata
    //  - Assumes file at audioPath exists
    await UserRec.writeMetadata(audioPath, metadata);

    // Make UserSource
    const userSource = await UserRec.sourceFromAudioPath(audioPath);
    if (!userSource) throw `stopRecording: audioPath from Nativespectro.stop() should load to a source: ${audioPath}`;

    // Log (before notify)
    UserRec.log.info('new', rich({audioPath, metadata, userSource}));

    // Notify listeners that a new UserRec was created (e.g. SavedScreen)
    Rec.emitter.emit('user', userSource);

    return userSource;
  },

  // (Callers: RecordScreen "Done editing" button)
  //  - Creates file (via editAudioPathToAudioPath)
  newFromEdit: async (props: {parent: Rec, draftEdit: DraftEdit}): Promise<UserSource> => {
    const parent  = props.parent;
    var draftEdit = props.draftEdit;

    // Attach to grandparent (flat) i/o parent (recursive), else we'd have to deal with O(n) parent chains
    //  - Load parent's UserMetadata, if a user rec
    //  - Else, attach to parent with our edit
    const parentSource = Rec.source(parent);
    const parentEdit: null | Edit = await matchSource(parentSource, {
      xc:   async ()           => null,
      user: async ({metadata}) => metadata.edit, // null | Edit
    });
    const edit = matchNull(parentEdit, {
      null: () => ({
        // Make a new edit rec rooted at parent (which isn't already an edit rec, by construction above)
        parent: parentSource,
        edits:  [draftEdit],
      }),
      x: parentEdit => ({
        // Preserve parent's parent, adding draftEdit to its edits
        parent: parentEdit.parent,
        edits:  [...parentEdit.edits, draftEdit],
      }),
    });

    // Make userSource <- metadata <- edit
    const userSource = UserSource.new({
      ext:      UserRec.audioExt,
      metadata: UserMetadata.new({
        created: new Date(),
        uniq:    chance.hash({length: 8}),
        edit,
        coords: null, // TODO Copy coords from XCRec (.lat,.lng) / UserRec (.metadata.coords)
        species: {kind: 'unknown'}, // 'unknown' species even if parent is known, e.g. clipping down to an unknown bg species
      }),
    });
    UserRec.log.info('newFromEdit', rich({userSource}));

    // Edit parent audio file -> edit audio file
    const audioPath = UserRec.audioPath(userSource);
    await NativeSpectro.editAudioPathToAudioPath({
      parentAudioPath: Rec.audioPath(parent),
      editAudioPath:   await ensureParentDir(audioPath),
      draftEdit,
    });

    // Write user metadata
    //  - Requires audioPath to exist (created above by editAudioPathToAudioPath)
    await UserRec.writeMetadata(audioPath, userSource.metadata);

    // Notify listeners that a new UserRec was created (e.g. SavedScreen)
    Rec.emitter.emit('user', userSource);

    return userSource;
  },

  // (Callers: listAudioSources, UserRec.new)
  sourceFromAudioPath: async (audioPath: string): Promise<UserSource | null> => {
    const {ssp} = SourceId.split(UserRec.sourceIdFromAudioPath(audioPath));
    return await UserSource.load(ssp);
  },

  // (Callers: sourceFromAudioPath, UserRec.writeMetadata)
  sourceIdFromAudioPath: (audioPath: string): SourceId => {
    const filename = basename(audioPath);
    const ssp      = filename;
    return `user:${ssp}`;
  },

  // (Callers: SavedScreen.loadSavedsFromFs)
  listAudioSources: async (): Promise<Array<UserSource>> => {
    return _.flatten(await Promise.all(
      (await UserRec.listAudioPaths(UserRec.audioDir)).map(async audioPath => {
        const source = await UserRec.sourceFromAudioPath(audioPath);
        if (!source) {
          UserRec.log.info('listAudioSources: Source not found, dropping', pretty({audioPath}));
          return [];
        } else {
          return [source];
        }
      })
    ));
  },

  // (Callers: listAudioSources)
  listAudioPaths: async (dir: string): Promise<Array<string>> => {
    return (await UserRec.listAudioFilenames(dir)).map(x => `${dir}/${x}`);
  },

  // (Callers: listAudioPaths)
  listAudioFilenames: async (dir: string): Promise<Array<string>> => {
    const excludes = [/\.metadata\.json$/]; // Back compat
    return (
      (await fs.ls(await ensureDir(dir)))
      .filter(x => !_.some(excludes, exclude => exclude.test(x)))
      .sort()
    );
  },

};
